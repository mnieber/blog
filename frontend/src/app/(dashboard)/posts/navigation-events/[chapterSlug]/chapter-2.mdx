# Introduction

By route management, I mean the following:

- declaring a schema that specifies which routes exists and which parameters they have;
- declaring a router that displays a React view component based on the current url;
- exposing route update functions that can change the url based on a route name and associated route parameters.

In this section we'll look at these three aspects in detail. In the next section, we'll see how components
can fire navigation events that update the url through the route update functions.

# Declaring routes

In my approach, every application module can expose a `RouteTable` instance, together with a type that
contains the signature of each route. Here is the route table for the `posts` module:

export const code1 = `
import { RouteTable } from '/src/routes/utils/RouteTable';

export const getRouteTable = () => {
  const routeTable = new RouteTable();

  routeTable.addRoutes({
    post: () => '/posts/:postSlug',
    posts: () => '/posts',
  });

  return routeTable;
};

export type RoutesT = {
  post: (args: { postSlug: string }) => void;
  posts: () => void;
};
`;

export const code2 = `
import { getRouteTable as getPostsRouteTable } from '/src/posts/routeTable';

const routeTable = getPostsRouteTable();

const routes = routeTable.routeFnByName;
const routeWithoutInterpolation = routes.post();  // "/posts/:postSlug"
const routeWithInterpolation = routes.post({ postSlug: 'foo' });  // "/posts/foo"
`;

<TabView titles={["/src/posts/RouteTable.ts", "example.ts"]}>
<CodeSnippet code={code1} />
<CodeSnippet code={code2} />
</TabView>

As you can see in `/src/posts/RouteTable.ts`, the information about each route is specified twice.
This is unfortunate, but necessary to get type safety.
In `example.ts` we see that we can call `routes.post()` with or without parameters, which returns
the route with or without value interpolation. We need the second variation (without interpolation)
when we set up the route in the router, as we will see below.

# Declaring the router

In `RouteTableProvider.tsx` we see how the routes for all modules are combined into a single route table.
This single route table is stored in a context and provided to all components that need it.
In `UrlRouter.tsx` we use the `useRoutes` hook to get access to these routes. We specify the types of
the routes that we want to use: `PostsRoutesT & FramesRoutesT`. This isn't perfectly
safe as we need to trust that `RouteTableProvider` in fact provides these routes, but it's better than nothing.

export const code3 = `
// In /src/routes/components/RouteTableProvider.tsx we add the route tables
// from each module into a single table.

import React from 'react';
import { getRouteTable as getPostsRouteTable } from '/src/posts/routeTable';
import { getRouteTable as getFramesRouteTable } from '/src/frames/routeTable';
import { RouteTable } from '/src/routes/utils/RouteTable';

export const RouteTableContext = React.createContext<RouteTable>(
  new RouteTable()
);

type PropsT = React.PropsWithChildren<{}>;

export const RouteTableProvider = (props: PropsT) => {
  const routeTable = new RouteTable();
  routeTable.addTable(getPostsRouteTable());
  routeTable.addTable(getFramesRouteTable());

  return (
    <RouteTableContext.Provider value={routeTable}>
      {props.children}
    </RouteTableContext.Provider>
  );
};
`;

export const code4 = `
// In /src/app/components/App.tsx the App component wraps the UrlRouter
// in a RouteTableProvider.

import React from 'react';
import { RouteTableProvider, UrlRouter } from '/src/routes/components";

export const App = () => {
  return (
    <RouteTableProvider>
      <UrlRouter />
    </RouteTableProvider>
  );
};
`;

export const code5 = `
// In /src/routes/components/UrlRouter.tsx we add Routes using the useRoutes hook.

import { RoutesT as PostsRoutesT } from '/src/posts/routeTable';
import { RoutesT as FramesRoutesT } from '/src/frames/routeTable';

export const UrlRouter = observer(() => {
  const routes = useRoutes<PostsRoutesT & FramesRoutesT>();

  return (
    <Route path={routes.posts()}>
      {
        // Show list of posts
      }
      <PostListView className="mt-12" />
      {
        // Show a particular post
      }
      <Route path={routes.post()}>
        <PostView className="mt-16"/>
      </Route>
    </Route>
  );
});
`;

<TabView titles={["RouteTableProvider.tsx", "App.tsx", "UrlRouter.ts"]}>
<CodeSnippet code={code3} />
<CodeSnippet code={code4} />
<CodeSnippet code={code5} />
</TabView>

# Using route update functions

A route update function is similar to a route function, but instead of returning a route, it updates the url.
We will use these functions in the next section when we discuss navigation events.

export const code6 = `
import { getRouteTable as getPostsRouteTable } from '/src/posts/routeTable';

const routeTable = getPostsRouteTable();

const routeUfns = routeTable.routeFnByName;
routeUfns.post({ postSlug: 'foo' });  // updates the url to "/posts/foo"
`;

<CodeSnippet title="example.ts" code={code6} />
