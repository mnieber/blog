# Introduction

By route management, I mean the following:

- declaring a schema that defines routes and their parameters;
- declaring a router component that displays a React view based on the current url;
- exposing route update functions that convert a route name and associated route parameters into a url.

In this chapter we'll look at these three aspects in detail. In the next chapter, we'll see how components
can fire navigation events that cause url changes.

# Declaring routes

The advantage of declaring routes separately is that we can use them in the router, but also in any
other function, as we shall see later. I declare my routes in a `RouteTable` instance, together with a
`RoutesT` type that contains the signature of each route. Here is the route table for the `posts` module:

export const code1 = `
import { RouteTable } from '/src/routes/utils/RouteTable';

export const getRouteTable = () => {
  const routeTable = new RouteTable();

  routeTable.addRoutes({
    post: () => '/posts/:postSlug',
    posts: () => '/posts',
  });

  return routeTable;
};

export type RoutesT = {
  post: (args: { postSlug: string }) => void,
  posts: () => void,
};
`;

export const code2 = `;
import { getRouteTable as getPostsRouteTable } from '/src/posts/routeTable';

const routeTable = getPostsRouteTable();

const routes = routeTable.routeFnByName;
// route = "/posts/:postSlug"
const route = routes.post();
// routeInterpolated = "/posts/foo"
const routeInterpolated = routes.post({ postSlug: 'foo' });
`;

export const code3 = `
// In /src/routes/components/RouteTableProvider.tsx we add the route tables
// from each module into a single table.

import React from 'react';
import { getRouteTable as getPostsRouteTable } from '/src/posts/routeTable';
import { getRouteTable as getFramesRouteTable } from '/src/frames/routeTable';
import { RouteTable } from '/src/routes/utils/RouteTable';

export const RouteTableContext = React.createContext<RouteTable>(
  new RouteTable()
);

type PropsT = React.PropsWithChildren<{}>;

export const RouteTableProvider = (props: PropsT) => {
  const routeTable = new RouteTable();
  routeTable.addTable(getPostsRouteTable());
  routeTable.addTable(getFramesRouteTable());

return (

<RouteTableContext.Provider value={routeTable}>
  {props.children}
</RouteTableContext.Provider>
); }; `;

<TabView titles={['/src/posts/RouteTable.ts', 'example.ts', 'RouteTableProvider.tsx']}>
  <CodeSnippet code={code1} />
  <CodeSnippet code={code2} />
  <CodeSnippet code={code3} />
</TabView>

As you can see in `/src/posts/RouteTable.ts`, the information about each route is specified twice.
This is unfortunate, but necessary to get type safety.

Now that the routes are declared we can use `routeTable.routeFnByName` to access the so-called route
functions, as shown in `example.ts`. A route function returns the route as a string. When we pass parameters
to the route function then value interpolation is performed. When we add the route to the router (we will
discuss this below) then we don't pass parameters, so that we obtain a route string that contains the
parameter-names.

Finally, in `RouteTableProvider.tsx` we see how the route tables for all modules are combined into a single
route table. This single route table is stored in a context and provided to all components that need it.

# Route update functions

A route update function is similar to a route function, but instead of returning a route, it updates the url.
We will use these functions in the next chapter when we discuss navigation events.

export const code6 = `
import { getRouteTable as getPostsRouteTable } from '/src/posts/routeTable';

const routeTable = getPostsRouteTable();

const routeUfn = routeTable.routeUfnByName.post;
routeUfn({ postSlug: 'foo' }); // updates the url to "/posts/foo"
`;

<CodeSnippet title="example.ts" code={code6} />

# Declaring the router

The example code below shows how to declare a router. The `UrlRouter` component is wrapped in a
`RouteTableProvider` so that it can access the route table. The `UrlRouter` component uses the `useRoutes`
hook to access these routes.

export const code4 = `
// In /src/app/components/App.tsx the App component wraps the UrlRouter
// in a RouteTableProvider.

import React from 'react';
import { RouteTableProvider, UrlRouter } from '/src/routes/components";

export const App = () => {
  return (
    <RouteTableProvider>
      <UrlRouter />
    </RouteTableProvider>
  );
};
`;

export const code5 = `
// In /src/routes/components/UrlRouter.tsx we add Routes using the useRoutes hook.

import { RoutesT as PostsRoutesT } from '/src/posts/routeTable';
import { RoutesT as FramesRoutesT } from '/src/frames/routeTable';

export const UrlRouter = observer(() => {
  const routes = useRoutes<PostsRoutesT & FramesRoutesT>();

  return (
    <Route path={routes.posts()}>
      { /* Show list of posts */ }
      <PostListView className="mt-12" />
      { /* Show a particular post */ }
      <Route path={routes.post()}>
        <PostView className="mt-16" />
      </Route>
    </Route>
  );
});`;

<TabView titles={['App.tsx', 'UrlRouter.ts']}>
  <CodeSnippet code={code4} />
  <CodeSnippet code={code5} />
</TabView>

In `useRoutes` we specify the types of the routes that we want to use:
`PostsRoutesT & FramesRoutesT`. This isn't perfectly safe as we need to trust that `RouteTableProvider` in fact
provides these routes, but in practice this works well enough.