import { aphorisms } from '/src/api/data/aphorisms';

# The sync-url-effect

The need for synchronizing the application state with the url is most obvious when
the application is loaded. The url will point to some application page that requires
a certain state that includes data (e.g. the blog-posts) and meta-data (e.g. the id of
the highlighted blog-post). In this chapter, I will not discuss data fetching, which is the
topic of [this post](/posts/state-providers/chapter-1). Instead, I will show
a `SyncPostWithUrlEffect` that:

- Ensures that the correct post is highlighted, based on the current url;
- Updates the url when the highlighted post changes.

Here is the code:

export const code1 = `
type PropsT = {};

const DefaultProps = {
  ...dps.posts,              // of type PostT[]
  ...dps.postsHighlight,     // of type Highlight<PostT>
};

export const SyncPostWithUrlEffect = observer(
  withDefaultProps((props: PropsT & typeof DefaultProps) => {
    const { postsHighlight, posts } = props;

    const location = useLocation();
    const { postSlug } = useParams() as ObjT;
    const refUrl = React.useRef<string>('');

    React.useEffect(() => {
      // If there is a new url
      if (refUrl.current !== location.pathname) {
        const postForCurrentUrl = R.find(
          (x: PostT) => x.slug === postSlug
        )(posts);

        if (postForCurrentUrl) {
          refUrl.current = location.pathname;
          if (postsHighlight.id !== postForCurrentUrl.id) {
            postsHighlight.highlightItem({ id: postForCurrentUrl?.id });
          }
        }
      } else {
        // Check if we must update the current url based on the highlighted post.
        const post = postsHighlight.item;
        if (post && postSlug !== post.slug) {
          navToPost(post.ownerUsername, post.slug);
        }
      }
    }, [postSlug, post, posts, postsHighlight]);

    return null;
  }, DefaultProps)
);
`;

<CodeSnippet
  title="SyncPostWithUrlEffect.tsx"
  code={code1}
  addMb
/>

Note that the example code depends on some of other libraries that are discussed in
this [post about Skandha](/posts/skandha/chapter-1) and this
[post about default properties](/posts/default-props/chapter-1). Here I will briefly
explain what these libraries do, so that you can understand the example:

- the `react-default-props-context` library provides a `withDefaultProps` function that
  can be used to define default properties for a component. The `DefaultProps` constant
  declares which default properties are used (in our case: `posts` and `postsHighlight`).
  These default properties are provided (using a React context) by a `DefaultPropsProvider`.
- the `skandha` library provides reusable behaviours, such as `Highlight`. In the example
  code, we're assuming that a `Highlight` object is used to track the highlighted post.


# Inserting the sync-url-effect in the router

The `SyncPostWithUrlEffect` must be inserted in the appropriate place in the component tree.
Specifically, it must be inserted at a location where there is a `postSlug` url parameter,
and where `posts` and `postsHighlight` are available as default properties. In the example below,
the default properties are provided by the `PostsStateProvider` component. The `SyncPostWithUrlEffect`
is inserted inside of the `Route` element that adds the `postSlug` url parameter.

export const code2 = `
export const UrlRouter = observer((props: PropsT) => {
  return (
    <PostsStateProvider>
      <Route path="/posts">
        <PostsView />

        <Route path="/posts/:postSlug">
          <SyncPostWithUrlEffect />
          <PostsView />
        </Route>

      </Route>
    </PostsStateProvider>
  );
});`;

<CodeSnippet
  title="UrlRouter.tsx"
  code={code2}
  addMb
/>
