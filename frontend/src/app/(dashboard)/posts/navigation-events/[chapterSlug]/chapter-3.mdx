# Introduction

In the last section we saw how to obtain a route update function and use it to change the url.
I will first describe the standard way of triggering url changes, and then describe a more
decoupled approach that is based on a navigation handler and navigation pages.

## How url changes are usually triggered

The easiest way to trigger url changes in components is to call `history.push` inside of the component.
However, this limits reuse. A better way is to pass a property into the component that takes
care of the navigation. This allows us to decide the desired navigation on a higher level (usually
a parent component). However, this might not be the best way to achieve decoupling, for two reasons.

First, since we pass the navigation function as a property, it requires (potentially multiple
levels of) prop drilling. This is annoying, but doable. However, it also bothers to make the components
responsible for setting up the navigation handling. Intuitively, I would rather use the exception handling
model for navigation, where navigation requests are like exceptions that bubble up until they are handled
at some higher layer.

The second reason is that this approach limits navigation handling to branches of the
rendering tree. For example, the sidebar and the central canvas will each define their own
navigation functions. This seems reasonable, and it usually works, but it doesn't really support the case
where the desired navigation depends on the current application page (as indicated by the url).
We can dispatch on the application url inside of the navigation function but this is clunky.

In my current opinion (my thinking is still evolving on this topic), it would be better
to define the navigation handling per application page, and handle navigation requests from the side bar
and main canvas in the same place. If the navigation function must know who requested the navigation then
we can pass this information into the request itself.

## A decoupled approach for triggering url changes

To illustrate the approach I outlined above, consider an application that shows blog-posts. The application
has a page with current blog-posts, and a page with archived blog-posts. Both pages use a `BlogPostList`
component. When `BlogPostList` wants to change the url, it sends a `navToPost` request to the
navigation handler. The navigation handler then finds the implementation of `navToPost` that corresponds to
the current url. For example, if the navigation requests happened on the archive page then `navToPost` will
navigate to `/archived-posts/:post-slug`. What's important is that `BlogPostList` can remain agnostic of how the
url must be changed.

The corresponding work-flow is as follows:

1. The component calls `navToPost(post)` to trigger a url change.
2. The `navToPost` function calls `navHander.getNavFn('navToPost')(post)`.
3. The navigation handler finds the navigation page for the current url that implements `navToPost`.
   It returns the page-specific navigation function (e.g. `archiveNavPage.navToPost`).
4. Finally, the page-specific navigation function calls the appropriate route update function to update the url.

export const code1 = `
import { navToPost } from '/src/posts/navEvents';

export type PropsT = { /* omitted for brevity */ };

export const PostListView = observer((props: PropsT) => {
  const postDivs = props.posts.map((post, idx) => {
    return (
      <PostListViewItem
        key={\`item-\$\{post.id\}\`}
        post={post}
        onClick={(e: any) => navToPost(post)}
      />
    );
  });
  return (
    <div className={cn('PostListView', props.className)}>
      {postDivs}
    </div>
  );
});
`;

export const code2 = `
// This file declares two navigation handler signatures. As we shall see,
// we need to install one or more navigation pages that implement these functions.

import { PostT } from '/src/api/types/PostT';
import { navHandler } from 'react-nav-handler';

export const navToPost = (post: PostT): void =>
  navHandler.getNavFn('navToPost', navToPost)(post);
export const navToPosts = (): void =>
  navHandler.getNavFn('navToPosts', navToPosts)();
`;

<TabView titles={['PostListView.tsx', 'posts/navEvents.ts']}>
  <CodeSnippet code={code1} />
  <CodeSnippet code={code2} />
</TabView>

# Declaring and installing navigation pages

To make the above code work, we need to install one or more navigation pages
that implement the handlers that were declared in `posts/navEvents.ts`:

- the `DashboardNavPage` and `ArchiveNavPage` components both implement `navToPost` and `navToPosts`.
- in `UrlRouter` we add the `DashboardNavPage` component, that will be mounted when the user
  visits the `/posts` page;
- we also add the `ArchiveNavPage` component that will be mounted when the user visits the
  `/archive` page.

export const code3 = `
import { useInstallNavPage, navHandler } from '/src/navHandler';

export const createArchiveNavPage = () => {
  return {
    navToPost: ((post: PostT) => {
      const ufn = navHandler.routeUfns.archivedPost(navHandler.history.push);
      ufn(post);
    }) as typeof navToPost,
    navToPosts: (() => {
      const ufn = navHandler.routeUfns.archivedPosts(navHandler.history.push);
      ufn();
    }) as typeof navToHome,
  };
};

export type PropsT = React.PropsWithChildren<{}>;

export const ArchiveNavPage = observer((props: PropsT) => {
  useInstallNavPage('ArchiveNavPage', createArchiveNavPage());
  return <>{props.children}</>;
});
`;

export const code4 = `
import { useInstallNavPage, navHandler } from '/src/navHandler';

export const createDashboardNavPage = () => {
  return {
    navToPost: ((post: PostT) => {
      const ufn = navHandler.routeUfns.post(navHandler.history.push);
      ufn(post);
    }) as typeof navToPost,
    navToPosts: (() => {
      const ufn = navHandler.routeUfns.posts(navHandler.history.push);
      ufn();
    }) as typeof navToHome,
  };
};

export type PropsT = React.PropsWithChildren<{}>;

export const DashboardNavPage = observer((props: PropsT) => {
  useInstallNavPage('DashboardNavPage', createDashboardNavPage());
  return <>{props.children}</>;
});
`;

export const code5 = `
export const UrlRouter = observer((props: PropsT) => {
  const routes = useRoutes();

return (

<Switch>
  <Route path={routes.dashboard()}>
    <DashboardNavPage>
      <DashboardView />
    </DashboardNavPage>
  </Route>
  <Route path={routes.archive()}>
    <ArchiveNavPage>
      <ArchiveView />
    </ArchiveNavPage>
  </Route>
</Switch>
); });`;

<TabView titles={['ArchiveNavPage.ts', 'DashboardNavPage.ts', 'UrlRouter.tsx']}>
  <CodeSnippet code={code3} />
  <CodeSnippet code={code4} />
  <CodeSnippet code={code5} />
</TabView>

# A complete workflow for handling navigation events

With this new code in mind, it's useful to analyse the complete workflow for handling navigation
events:

1. Suppose that the current url is `/dashboard/posts/foo`. The `UrlRouter` will render `DashboardView` and `DashboardNavPage`
   will be mounted.
2. When `DashboardNavPage` mounts then it registers itself with the navigation handler, using `/dashboard` as the url.
3. When the user clicks on a post in the `PostListView` then this is handled by calling `navToPost(post)`.
4. The navigation handler receives the `navToPost` request and finds the navigation page that best matches the current url.
   Since the current url is `/dashboard/posts/foo`, the `DashboardNavPage` (with associated url `/dashboard`) is the best match.
5. The navigation handler executes `navToPost` in that page. This executes the `navHandler.routeUfns.post`
   function to update the url.
