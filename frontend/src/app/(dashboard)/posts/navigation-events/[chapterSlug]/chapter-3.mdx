# Introduction

In the last section we saw how to obtain a route update function and use it to change the url.
We could use this directly in a React component but I prefer a more decoupled approach that is based
on a navigation handler and navigation pages.

To illustrate why this decoupling is useful, consider an application that shows blog-posts. The application
has a page with current blog-posts, and a page with archived blog-posts. Both pages use a `BlogPostList`
component. When `BlogPostList` wants to change the url, it can send a `navToPost` request to the
navigation handler. The navigation handler will update the url in a context-dependent way. For example,
if the navigation requests happened on the archive page then we can navigate to `/archived-posts/:post-d`.
What's important is that `BlogPostList` can remain agnostic of how the url must be changed.

The corresponding work-flow is as follows:

1. The component calls `navToPost(post)` to trigger a url change.
2. The `navToPost` function calls `navHander.getNavFn('navToPost')`.
3. The navigation handler finds the navigation page for the current url that implements `navToPost`.
   It returns `page.navToPost`.
4. Finally, in the body of `page.navToPost`, we call the appropriate route update function to update the url.

export const code1 = `
import { BlogPostsNavEvents, useNavHandler } from '/src/frames/pages';

export type PropsT = { /* omitted for brevity */ };

export const PostListView = observer((props: PropsT) => {
  const nav = useNavHandler<typeof BlogPostsNavEvents>();
  const postDivs = props.posts.map((post, idx) => {
    return (
      <PostListViewItem
        key={\`item-\$\{post.id\}\`}
        post={post}
        onClick={(e: any) => nav.navToPost(post)}
      />
    );
  });
  return (
    <div className={cn('PostListView', props.className)}>
      {postDivs}
    </div>
  );
});
`;

export const code2 = `
// This file declares two navigation handler signatures. As we shall see,
// we need to install one or more navigation pages that implement these functions.

import { PostT } from '/src/api/types/PostT';
import { navHandler } from '/src/navHandler/NavHandler';

export const navToPost = (post: PostT): void =>
  navHandler.getNavFn('navToPost', navToPost)(post);
export const navToPosts = (): void =>
  navHandler.getNavFn('navToPosts', navToPosts)();
`;

<TabView titles={['PostListView.tsx', 'BlogPostsNavEvents.ts']}>
  <CodeSnippet code={code1} />
  <CodeSnippet code={code2} />
</TabView>

# Declaring and installing navigation pages

To make the above code work correctly, we need to install one or more navigation pages
that implement the handlers that were declared in `BlogPostsNavEvents`:

- the `DashboardNavPage` and `ArchiveNavPage` components both implement `navToPost` and `navToPosts`.
- in `UrlRouter` we add the `DashboardNavPage` component, that will be mounted when the user
  visits the `/posts` page;
- we also add the `ArchiveNavPage` component that will be mounted when the user visits the
  `/archive` page.

export const code3 = `
import { useInstallNavPage, navHandler } from '/src/navHandler';

export const createArchiveNavPage = () => {
  return {
    navToPost: ((post: PostT) => {
      const ufn = navHandler.routeUfns.archivedPost(navHandler.history.push);
      ufn(post);
    }) as typeof navToPost,
    navToPosts: (() => {
      const ufn = navHandler.routeUfns.archivedPosts(navHandler.history.push);
      ufn();
    }) as typeof navToHome,
  };
};

export type PropsT = React.PropsWithChildren<{}>;

export const ArchiveNavPage = observer((props: PropsT) => {
  useInstallNavPage('ArchiveNavPage', createArchiveNavPage());
  return <>{props.children}</>;
});
`;

export const code4 = `
import { useInstallNavPage, navHandler } from '/src/navHandler';

export const createDashboardNavPage = () => {
  return {
    navToPost: ((post: PostT) => {
      const ufn = navHandler.routeUfns.post(navHandler.history.push);
      ufn(post);
    }) as typeof navToPost,
    navToPosts: (() => {
      const ufn = navHandler.routeUfns.posts(navHandler.history.push);
      ufn();
    }) as typeof navToHome,
  };
};

export type PropsT = React.PropsWithChildren<{}>;

export const DashboardNavPage = observer((props: PropsT) => {
  useInstallNavPage('DashboardNavPage', createDashboardNavPage());
  return <>{props.children}</>;
});
`;

export const code5 = `
export const UrlRouter = observer((props: PropsT) => {
  const routes = useRoutes();

return (

<Switch>
  <DashboardNavPage>
    <Route path={routes.dashboard()}>
      <DashboardView />
    </Route>
  </DashboardNavPage>
  <ArchiveNavPage>
    <Route path={routes.archive()}>
      <ArchiveView />
    </Route>
  </ArchiveNavPage>
</Switch>
); });`;

<TabView titles={['ArchiveNavPage.ts', 'DashboardNavPage.ts', 'UrlRouter.tsx']}>
  <CodeSnippet code={code3} />
  <CodeSnippet code={code4} />
  <CodeSnippet code={code5} />
</TabView>

# A complete workflow for handling navigation events

With this new code in mind, it's useful to analyse the complete workflow for handling navigation
events:

1. Suppose that the current url is `/dashboard/posts/foo`. The `UrlRouter` will render `DashboardView` and `DashboardNavPage`
   will be mounted.
2. When `DashboardNavPage` mounts it registers itself with the navigation handler, using `/dashboard` as the url.
3. The user clicks on a post in the `PostListView`. This click is handled by `PostListView` which calls `navToPost(post)`.
4. The navigation handler receives the `navToPost` request and finds the navigation page that best matches the current url.
   Since the current url is `/dashboard/posts/foo`, the `DashboardNavPage` (with associated url `/dashboard`) is the best match.
5. The navigation handler executes `navToPost` in that page. This executes the `navHandler.routeUfns.post`
   function to update the url.
