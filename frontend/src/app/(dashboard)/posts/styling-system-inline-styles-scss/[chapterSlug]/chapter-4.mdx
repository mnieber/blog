# Introduction

In the previous chapter we've introduced style objects. We extended these style objects first by adding choices, and then by
adding intrinsic styles (that are defined in an .scss file). These changes move the use of a style objects more towards that
of custom components. The logical next step is to introduce a custom component that makes use of a style object.
In this chapter I will illustrate this scenario, and explain how we can also add theming.

# Combining a custom component with a style object

Style objects are loosely defined components that we can mix into concrete components. However, when we always mix the style component
into the same JSX structure then it can make sense to use a full-blown custom component that contains JSX.
So far, we've looked at the example of a `FormField` but this is a case where you would probably not introduce a custom component.
Therefore, I will instead show the example of a `DialogButton`.

export const code1 = `
import { classnames as cn } from 'classnames';

import "./DialogButton.scss";

export type PropsT = {
  className?: any;
  disabled?: boolean;
  fontSize?: 'medium' | 'big';
  iconName?: string;
  label: string;
  // Some other props omitted...
};

export const DialogButton = (props: PropsT) => {
  const { className, fontSize, iconName, label, ...rest } = props;
  const hasIcon = !!iconName;

  return (
    <button
      className={cn(
        'DialogButton',
        { 'DialogButton--disabled': disabled },
        [
          DialogButtonS.fontSize[fontSize](),
          hasIcon ? 'flex flex-row items-stretch' : '',
          className
        ]
      )}
      {...rest}
    >
      {hasIcon && (
        <div className={cn(DialogButtonS.Icon())}>
          {icons[props.iconName]}
        </div>
      }
      {label}
    </button>
  );
};

export const DialogButtonS = {
  fontSize: {
    medium: () => 'text-base',
    big: () => 'text-lg',
  },
  Icon: () => cn('DialogButton__Icon', 'mr-2'),
};
`;

export const code2 = `
.DialogButton {
  @apply select-none;

  .DialogButton--disabled {
    @apply text-gray-400;
  }

  .DialogButton__Icon {
    // All dialog buttons have the same icon size
    @apply h-[20px] w-[20px] min-w-[20px];
  }
}
`;

<TabView titles={['DialogButton.tsx', 'DialogButton.scss']}>
  <CodeSnippet code={code1} />
  <CodeSnippet lang="sass" code={code2} />
</TabView>

In this example we've introduced a `DialogButton` custom component that uses a style object. The button will have an icon
if the `iconName` property is provided. Note that the `fontSize` parameter is used to pick a style from the style object.
Also note that client code can use the style object even when it doesn't need the custom component.

# Theming a custom component using a componentClassName property

Theming our `DialogButton` component implies selecting a new set of intrinsic styles. The ad-hoc styles can
already be chosen in a context-dependent way so there is no reason to include them in the theme. Here is an example of a
`DialogButton` that can be styled with the `Blue` theme or `Teal` theme (we'll show the `Blue` theme and omit most of the
`Teal` theme):

export const code3 = `
import { classnames as cn } from 'classnames';

import "./DialogButton.scss";
import "./Blue-DialogButton.scss";
import "./Teal-DialogButton.scss";

export type PropsT = {
  className?: any;
  componentClassName?: 'Blue-DialogButton' | 'Teal-DialogButton',
  disabled?: boolean;
  fontSize?: 'medium' | 'big';
  iconName?: string;
  label: string;
  // Some other props omitted...
};

export const DialogButton = (props: PropsT) => {
  const { className, fontSize, iconName, label, ...rest } = props;
  const hasIcon = !!iconName;

  const name = props.componentClassName ?? 'DialogButton';

  return (
    <button
      className={cn(
        name,
        { [name + '--disabled']: props.disabled },
        [
          'select-none',
          DialogButtonS.fontSize[fontSize](),
          hasIcon ? 'flex flex-row items-stretch' : '',
          className
        ]
      )}
      {...rest}
    >
      {hasIcon && (
        <div className={cn(DialogButtonS.Icon())}>
          {icons[props.iconName]}
        </div>
      }
      {label}
    </button>
  );
};

export const DialogButtonS = {
  fontSize: {
    medium: () => 'text-base',
    big: () => 'text-lg',
  },
  Icon: () => cn('DialogButton__Icon', 'mr-2'),
};
`;

export const code4 = `
.Blue-DialogButton {
  @apply text-blue-400;

  .DialogButton--disabled {
    @apply text-gray-400;
  }

  .DialogButton__Icon {
    @apply h-[20px] w-[20px] min-w-[20px];
  }
}
`;

<TabView titles={['DialogButton.tsx', 'Blue-DialogButton.scss']}>
  <CodeSnippet code={code3} />
  <CodeSnippet lang="sass" code={code4} />
</TabView>

Note that inside the `.Blue-DialogButton` selector there are rules for `.DialogButton--disabled` and
`.DialogButton__Label`. Since we are already in the scope of the themed button, there is no reason to introduce
new names for these selectors.

Note also that we've moved the `select-none` class from the .scss file to the JSX code. This is a pragmatic way to ensure
that all buttons have `select-none` and removes the need to add this class to every theme.

# Using themeClassName instead of componentClassName

A variation on the above approach is to have a `themeClassName` that can be `Blue` or `Teal`. This approach is useful when
a component and its sub-components (in this case: `Icon`) should all use the same theme:

export const code5 = `
export const DialogButton = (props: PropsT) => {
  const { className, fontSize, iconName, label, ...rest } = props;
  const hasIcon = !!iconName;

  const name = props.themeClassName
    ? (props.themeClassName + '-DialogButton')
    : 'DialogButton';

  return (
    <button
      className={cn(
        name,
        { [name + '--disabled']: props.disabled },
        [
          'select-none',
          DialogButtonS.fontSize[fontSize](),
          hasIcon ? 'flex flex-row items-stretch' : '',
          className
        ]
      )}
      {...rest}
    >
      {hasIcon && <Icon themeClassName={props.themeClassName} name={props.iconName} />}
      {label}
    </button>
  );
};
`;

export const code6 = `
import "./Icon.scss";
import "./Blue-Icon.scss";
import "./Teal-Icon.scss";

export const Icon = (props: PropsT) => {
  const name = props.themeClassName ? (props.themeClassName + '-Icon') : 'Icon';

  return (
    <div className={cn(name)}>
        {icons[props.iconName]}
    </div>
  );
};
`;

<TabView titles={['DialogButton.tsx', 'Icon.tsx']}>
  <CodeSnippet code={code5} />
  <CodeSnippet code={code6} />
</TabView>

# Theming custom components using an SCSS scope

We've seen above that we can use CSS classes such as `DialogButton` and `DialogButton__Icon` to apply intrinsic styles.
An interesting possibility is to make the intrinsic styles context-dependent. For example, a dialog button on an
authentication page might look different from a button on a user-preferences page. We have to be very careful
though that we don't introduce a lot of complexity to make this happen. Ideally, one of the following should be the case:

- The intrinsic style is defined in only one place.
- The intrinsic style is defined for different contexts. For every context, it is defined in only one place.

In addition, we want to ensure that it's easy to find the intrinsic style rule for any occurrence of its associated CSS class
in the DOM. Here is an example that illustrates how this can be achieved:

export const code7 = `
// We'll import all themed variations on DialogButton in
// the DialogButton.tsx file itself

import "./DialogButton.AuthCard.scss";
import "./DialogButton.UserProfileCard.scss";

export const DialogButton = (props: PropsT) => {
  // This code is still the same
};
`;

export const code8 = `
// Note that we've put .AuthCard .DialogButton on one line.
// This will make it easier to find this code when we copy
// a selector in the browser's debugger.

.AuthCard .DialogButton {

  .DialogButton--disabled {
    @apply text-gray-400;
  }

  .DialogButton\_\_Icon {
    @apply fill-blue-400;
  }
}
`;

export const code9 = `
// Note that we've put .UserProfileCard .DialogButton on one line.
// This will make it easier to find this code when we copy
// a selector in the browser's debugger.

.UserProfileCard .DialogButton {
  @apply font-bold;

  .DialogButton--disabled {
    @apply text-gray-300;
  }

  .DialogButton\_\_Icon {
    @apply fill-teal-400;
  }
}
`;

<TabView titles={['DialogButton.tsx', 'DialogButton.AuthCard.scss', 'DialogButton.UserProfileCard.scss']}>
  <CodeSnippet code={code7} />
  <CodeSnippet lang="sass" code={code8} />
  <CodeSnippet lang="sass" code={code9} />
</TabView>
