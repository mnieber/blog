---
slug: 'chapter-3'
title: 'Hybrid approach for managing styles'
type: 'chapter'
---

# Introduction

In this chapter I will describe my custom solution. It aims to achieve a compromise between the strengths and
weaknesses of the approaches that I mentioned in the previous chapter:

- the starting point is the inline styling approach proposed by TailwindUI
- "intrinsic" styles are moved to a SCSS file that is co-located with the JSX file
- recurring patterns in the remaining styles are moved to a layout object. The fields of this layout object can be injected
  into JSX elements much like UIkit classes are injected.

# Breaking out intrinsic styles

When we use TailwindUI then inline styles are copied from a snippet and adjusted to suit the local context.
However, there is often a subset of styles that remain unchanged. These can be referred to as the component's intrinsic styles.
In my view, it's preferable to move these styles to a CSS class, reducing code clutter.
Let's examine an example where this principle is applied. In this example:

- the email-field code snippet from the previous chapter has been copied to the body of a SignInForm component;
- the intrinsic styles have been moved to rules in a SCSS file: `FormField__Label` and `FormField__Input`;

Following the "inline components" approach from UIkit, we've introduced a loosely
structured `FormField` component that has a label and an input. To apply this "inline component"
we add the `FormField__Label` and `FormField__Input` classes at the appropriate places in the email field (see below).
We can use the same CSS classes for other fields, such as the password field. This will work well as long as these fields
have the same intrinsic styles.

<TabView titles={["SignInForm.tsx", "SignInForm.scss"]}>
<CodeSnippet
  code={`
export const SignInForm = () => {
  return (
    <div className="SignInForm">
      {
        // Note that other parts of the SignInForm component
        // are omitted for brevity
      }
      <div className="FormField mb-6">
        <label for="email" className="FormField__Label mb-2">
          Email address
        </label>
        <div>
          <input
            id="email"
            name="email"
            type="email"
            className="FormField__Input py-1.5 w-full"
          />
        </div>
      </div>
    </div>
  );
};
`}
/>

<CodeSnippet lang="sass" code={`
.FormField__Label {
  @apply block text-sm font-medium leading-6 text-gray-900;
}

.FormField\_\_Input {
@apply block rounded-md border-0 shadow-sm;
@apply text-gray-900 placeholder:text-gray-400 sm:text-sm sm:leading-6;
@apply ring-1 ring-inset ring-gray-300 focus:ring-2 focus:ring-inset focus:ring-indigo-600;
}
`}/>

</TabView>

There are no rigid guidelines for determining which properties are intrinsic. For example, the padding of the
input field was chosen not to be intrinsic, probably because we can foresee that we need a different padding in
some cases. Usually, the reader can intuitively undertand why certain styles are inline while others are not.
In less obvious situations, such as when a margin appears in the SCSS file, it's helpful to include a comment.

# Ad-hoc properties and layouts

I refer to the properties that remain inline as ad-hoc properties. These typically involve the component's layout and geometry,
including flex-box properties, margins, heights, widths, and paddings. While ad-hoc properties can be adjusted to fit a specific context,
it's good for consistency to limit the variation in these properties. For instance, if an email field has a vertical padding of 1.5,
it's likely that the password field in the same form should also have this padding. To address this, I extract the ad-hoc properties and
place them in a layout object.

<TabView titles={["SignInForm.tsx", "layout.ts"]}>
<CodeSnippet
  code={`
import { classnames as cn } from 'classnames';

export const SignInForm = () => {
  return (
      ...
      <div className={cn(L.FormField.root())}>
        <label for="email" className={cn(L.FormField.label())}>
          Email address
        </label>
        <div>
          <input
            id="email"
            name="email"
            type="email"
            className={cn(L.FormField.input())}
          />
        </div>
      </div>
    </div>
  );
};
`}/>

<CodeSnippet
  code={`
export const L = {
  FormField: {
    // Use the root style in the top level element of the FormField
    root: () => 'FormField mb-6',
    // Use this style if the form-field contains a label
    label: () => 'FormField__Label mb-2',
    // Use this style if the form-field contains an input
    input: () => 'FormField__Input py-1.5 w-full',
  },
};
`}
/>
</TabView>

As indicated by the comments, it's not mandatory to use all the keys in the layout object. For example, the `label` key is only
utilized if the form-field includes a label. It's also possible to incorporate variations in the layout, as demonstrated below:

<TabView titles={["SignInForm.tsx", "layout.ts"]}>
<CodeSnippet
  code={`
import { classnames as cn } from 'classnames';

export const SignInForm = () => {
  return (
    <div className="SignInForm">
      <div
        className={cn(
          L.FormField.container.root(),
          L.FormField.container.gap.big()
        )}
      >
        <label
          for="email"
          className={cn(L.FormField.label.root(), L.FormField.label.color.blue())}
        >
          Email address
        </label>
      </div>
    </div>
  );
};
`}/>

<CodeSnippet
  code={`
export const L = {
  FormField: {
    // The container element is the top-level element that contains the entire form field
    container: {
      root: () => 'FormField',
      // Use one of the gap styles to create space below the form-field
      gap: {
        big: () => 'mb-6',
        small: () => 'mb-2',
      },
    },
    // Use this style if the form-field contains a label
    label: {
      root: () => 'FormField__Label mb-2',
      // Pick one color for the label
      color: {
        blue: () => 'text-blue-500',
        green: () => 'text-green-400',
      }
    }
    // Use this style if the form-field contains an input
    input: () => 'FormField__Input py-1.5 w-full',
  },
};
`}
/>
</TabView>

I typically include numerous comments in the layout object to clarify the intended use of each layout.
Of course, a developer might choose the wrong values from the layout, resulting in an inconsistent appearance.
However, since the use of a layout object constrains the variation in ad-hoc styles, it still promotes greater consistency.

# Making intrinsic styles context-dependent

We've seen above that we can use CSS classes such as `FormField` and `FormField__Label` to apply intrinsic styles.
An interesting possibility is to make the intrinsic styles context-dependent. For example, a form field on an
authentication page might look different from a form field on a user-preferences page. We have to be very careful
though that we don't introduce a lot of complexity to make this happen. Ideally, one of the following should be the case:

- The intrinsic style is defined in only one place.
- The intrinsic style is defined for different contexts. For every context, it is defined in only one place.

In addition, we want to ensure that it's easy to find the intrinsic style rule for any occurrence of its associated CSS class
in the DOM. Here is an example that illustrates how this can be achieved:

<CodeSnippet
  lang="sass"
  title="FormFieldBase.scss"
  code={`
.FormFieldBase__Label {
  font-family: 'Roboto', sans-serif;
}
`}
/>

<CodeSnippet
  lang="sass"
  title="AuthCard/FormField.scss"
  code={`
.AuthCard .FormField\_\_Label {
  @apply FormFieldBase\_\_Label;
  @apply text-sm;
}
`}
/>

<CodeSnippet
  lang="sass"
  title="UserProfileCard/FormField.scss"
  code={`
.UserProfileCard .FormField\_\_Label {
  @apply FormFieldBase\_\_Label;
  @apply text-base;
}
`}
/>

Note that in `AuthCard/FormField.scss` and `UserProfileCard/FormField.scss`, we purposely did not use nested SCSS rules.
Instead, we've put `.AuthCard .FormField__Label` on the same line. This will allow us to copy a selector from the browser's
debugger and use that to find the related style code. It's up to the programmer to ensure that `.AuthCard .FormField__Label`
and `.UserProfileCard .FormField__Label` are non-overlapping.

# How to move an instrinsic style back to inline?

It's interesting to consider what should happen when we decide that the font-size must be an ad-hoc property instead
of an intrinsic property. How should we refactor the code to avoid breaking something? The challenge here is that previously
we relied on the cascading nature of style-sheets to correctly style the FormField depending on the context (either
`.AuthCard` or `.UserProfileCard`). This allowed us to use the `.FormField` class without needing to know the
context of the element. Now that we want to make the font-size an ad-hoc property, we need to know the context of the element,
and apply a font-size of `text-sm` or `text-base` accordingly.

I propose the following workflow:

1. Find all instances of `FormField` in the typescript code (i.e. all .ts and .tsx files) and
   annotate them with a comment such as `// ad-hoc: font-size`.
2. For every annotated instance, check if the context of the `FormField` is known. If it is known, then add the correct font-size as an ad-hoc style.
   For example, if we know that the context is `AuthCard` then we add `text-sm`.
3. If the context is not known, then we must decide whether to parametrize the component (e.g. add a context attribute that can be either 'auth' or
   'user-profile') or create a copy of the component for every context. In the latter case, we must name each copy after the context, e.g.
   `AuthFormField` and `UserProfileFormField`.
4. At this point, our components are parametrized or renamed, but the call-sites (the places where these components are used) have not yet been
   updated. Fortunately, the typescript compiler will tell us where we broke the code. In each place, we must ask ourselves the same question:
   do we know the context? If the answer is yes, then we fix the code, for example by directly using `AuthFormField`, or by setting the value
   of the parameter that was introduced. If the answer is no, then we either parametrize or create a copy of the component, just like we did in the previous step.
   We repeat this process until all Typescript errors have been solved.
5. After fixing the code in step 4, we can remove the intrinsic style from the scss file, and remove the comments added in step 1.
